scalar DateTime

interface Node {
    id: ID!
}

enum OrderDirection {
    ASC
    DESC
}

enum Visibility {
    PRIVATE
    PUBLIC
}

type PageInfo {
    hasPreviousPage: Boolean!
    hasNextPage: Boolean!
    startCursor: String
    endCursor: String
}

schema {
    query: Query
    mutation: Mutation
}

type Query {
    ping: String!

    existEmail(email: String!): Boolean!
    existFullPath(fullPath: String!): Boolean!

    namespace(fullPath: String!): Namespace!

    viewer: User!
    user(username: String!): User!
}

type Mutation {
    # session
    createSession(input: CreateSessionInput!): CreateSessionPayload
    deleteSession: DeleteSessionPayload

    # user
    createUser(input: CreateUserInput!): CreateUserPayload
    deleteUser(input: DeleteUserInput!): DeleteUserPayload

    updateActivationEmail(input: UpdateActivationEmailInput!): UpdateActivationEmailPayload
    sendActivationEmail(input: SendActivationEmailInput!): SendActivationEmailPayload
    activateUser(input: ActivateUserInput!): ActivateUserPayload

    sendPasswordResetEmail(input: SendPasswordResetEmailInput!): SendPasswordResetEmailPayload
    resetPassword(input: ResetPasswordInput!): ResetPasswordPayload

    updateUser(input: UpdateUserInput!): UpdateUserPayload
    updateUsername(input: UpdateUsernameInput!): UpdateUsernamePayload
    updatePassword(input: UpdatePasswordInput!): UpdatePasswordPayload

    createEmail(input: CreateEmailInput!): CreateEmailPayload
    confirmEmail(input: ConfirmEmailInput!): ConfirmEmailPayload
    setPrimaryEmail(input: SetPrimaryEmailInput!): SetPrimaryEmailPayload
    deleteEmail(input: DeleteEmailInput!): DeleteEmailPayload
}

# session

type Session {
    email: String
    username: String!
    header: String!
    token: String!
    active: Boolean!
}

input CreateSessionInput {
    username: String!
    password: String!
}

type CreateSessionPayload {
    session: Session
}

type DeleteSessionPayload {
    message: String
}

# namespace

type Namespace implements Node {
    id: ID!
    createdAt: DateTime
    updatedAt: DateTime
    name: String
    path: String
    fullName: String
    fullPath: String
    visibility: Visibility
    description: String
}

# user

type User implements Node {
    id: ID!
    createdAt: DateTime
    updatedAt: DateTime
    name: String
    username: String
    active: Boolean
    role: Role
    avatarUrl: String
    bio: String
    location: String
    websiteUrl: String

    namespace: Namespace

    emails: EmailConnection
    unconfirmedEmails: EmailConnection
}

enum Role {
    USER,
    ADMIN
}

input CreateUserInput {
    email: String!
    name: String!
    username: String!
    password: String!
}

type CreateUserPayload {
    user: User
}

input DeleteUserInput {
    id: ID!
}

type DeleteUserPayload {
    user: User
}

input UpdateActivationEmailInput {
    email: String!
}

type UpdateActivationEmailPayload {
    message: String
}

input SendActivationEmailInput {
    email: String
}

type SendActivationEmailPayload {
    message: String
}

input ActivateUserInput {
    token: String!
}

type ActivateUserPayload {
    message: String
}

input SendPasswordResetEmailInput {
    email: String!
}

type SendPasswordResetEmailPayload {
    message: String
}

input ResetPasswordInput {
    token: String!
    password: String!
}

type ResetPasswordPayload {
    message: String
}

input UpdateUserInput {
    name: String!
    bio: String!
    location: String!
    websiteUrl: String!
}

type UpdateUserPayload {
    user: User
}

input UpdateUsernameInput {
    username: String!
}

type UpdateUsernamePayload {
    user: User
}

input UpdatePasswordInput {
    oldPassword: String!
    password: String!
    passwordConfirmation: String!
}

type UpdatePasswordPayload {
    user: User
}

# email

type Email implements Node {
    id: ID!
    createdAt: DateTime
    updatedAt: DateTime
    email: String!
    primary: Boolean!
}

type EmailEdge {
    node: Email!
    cursor: String!
}

type EmailConnection {
    edges: [EmailEdge!]
    pageInfo: PageInfo
}
input CreateEmailInput {
    email: String!
}

type CreateEmailPayload {
    email: Email
}

input ConfirmEmailInput {
    token: String!
}

type ConfirmEmailPayload {
    email: Email
}

input SetPrimaryEmailInput {
    email: String!
}

type SetPrimaryEmailPayload {
    email: Email
}

input DeleteEmailInput {
    email: String!
}

type DeleteEmailPayload {
    email: Email
}
